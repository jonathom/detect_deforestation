---
title: "Deforestation Detection"
author: "Brian Pondi, Jonathan Bahlmann"
date: "2/12/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

* Observe structure: Intro, Methods, Results, Discussion, Conclusion

# Introduction

# Methods

## Input Data and Preparations

* Package description
* PRODES data sorted by years can be found here: [PRODES yearly deforestation](http://terrabrasilis.dpi.inpe.br/download/dataset/legal-amz-prodes/vector/yearly_deforestation.zip)

As seen in "final.Rmd". The subdirectory `L8cube_subregion` contains a NDVI time series as single `.tif` files, a file per acquisition, as input data.
```{r, warning=FALSE, message=FALSE}
library(stars)
library(gapfill)
library(bfast)
library(zoo)
library(raster)
subdir = "landsat_monthly"
f = paste0(subdir, "/", list.files(subdir))
st = merge(read_stars(f)) # make stars object
# make subset to test Gapfill
st_subs <- st[,150:200,150:200,]

# load PRODES data
# prod <- read_sf("./yearly_deforestation/yearly_deforestation.shp")
# prod_3857 <- st_transform(prod, crs = st_crs(st))
# prod_crop <- st_crop(prod_3857, st) # clip
# write_sf(prod_crop, "./yearly_deforestation/PRODES_cropped.shp")
prod <- read_sf("./yearly_deforestation/PRODES_cropped.shp")
prod <- prod[prod$YEAR < 2019,]
```

```{r, warning=FALSE}
# whats in it?
# plot(st)
plot(as(st[,,,5], "Raster"))
plot(prod["YEAR"], add = TRUE)
plot(prod["YEAR"])
```

## Prepare for Gapfill

TODO: Introduce Gapfill, why did we chose this?

`Gapfill` documentation tells us that as input, a 4-dimensional numeric array is needed, with dimensions x, y, seasonal index (doy), year.
```{r}
# getpixel values of stars subset
imgdata_subs <- c(st_subs[,,,1:72][[1]])

# make labels
xlab <- seq(from = attr(st_subs, "dimensions")[[1]]$offset, by = attr(st_subs, "dimensions")[[1]]$delta, length.out = attr(st_subs, "dimensions")[[1]]$to - attr(st_subs, "dimensions")[[1]]$from)
ylab <- seq(from = attr(st_subs, "dimensions")[[2]]$offset, by = attr(st_subs, "dimensions")[[2]]$delta, length.out = attr(st_subs, "dimensions")[[2]]$to - attr(st_subs, "dimensions")[[1]]$from)
doi <- c(1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335)
years <- seq(2013,2018,1)

# make array
m <- array(imgdata_subs, dim = c(50, 50, 12, 6), dimnames = list(xlab, ylab, doi, years))
# transpose to switch y, x to x, y
m <- aperm(m, c(2,1,3,4))

# get pixels of whole dataset
imgdata <- c(st[,,,1:72][[1]])

# make labels
xlab <- seq(from = attr(st, "dimensions")[[1]]$offset, by = attr(st, "dimensions")[[1]]$delta, length.out = attr(st, "dimensions")[[1]]$to)
ylab <- seq(from = attr(st, "dimensions")[[2]]$offset, by = attr(st, "dimensions")[[2]]$delta, length.out = attr(st, "dimensions")[[2]]$to)
doi <- c(1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335)
years <- seq(2013,2018,1)

# make array, transpose
h <- array(imgdata, dim = c(540, 501, 12, 6), dimnames = list(xlab, ylab, doi, years))
h <- aperm(h, c(2,1,3,4))

# plot
# subset
# Image(m[,,5,1:2])
# original subset
# plot(st_subs[,,,c(5,17)])
# all
Image(h[,,5,1:2])
# original stars
plot(st[,,,c(5, 17)])
```

## Gapfill

```{r}
# d <- Gapfill(m)
# saveRDS(d, "50x50_Gapfill.rds")
g <- readRDS("50x50_Gapfill.rds")
Image(g$fill)
```

```{r}
# ts of a pixel
x <- as.vector(g$fill[1,1,,])
# time must be given scaled to 1. -> monthly -> 1/12 = .08333333
# zoo must also be used in between, exactly as in ?bfastmonitor example
y <- as.ts(zoo(x, seq(2013, by = .08333333, length.out = 72))) 
y

bf <- bfastmonitor(y, start = c(2018, 1))
bf
plot(bf)
```


```{r}
# single pixel
defo_test <- st[st_geometry(prod[2,])]
defo_test_ts <- as.vector(defo_test[,5,5,][[1]])
test_ts <- as.ts(zoo(defo_test_ts, seq(2013, by = .08333333, length.out = 72))) 
test <- bfastmonitor(test_ts, start = c(2018, 1))
plot(test)

# mean of this polygon
mean_test <- st_apply(st[st_geometry(prod[2,])], "attributes", mean,  na.rm = TRUE) # aggregate
defo_test_ts <- mean_test[][[1]]
test_ts <- as.ts(zoo(defo_test_ts, seq(2013, by = .08333333, length.out = 72))) 
test <- bfastmonitor(test_ts, start = c(2018, 1))
plot(test)

# calculate breaks for every single pixel
vec <- c(0)
count <- 1
for (i in 1:10) {
  for (j in 1:13) {
    ts <- defo_test[,i,j,][[1]]
    test_ts <- as.ts(zoo(ts, seq(2013, by = .08333333, length.out = 72)))
    
    if (length(unique(test_ts)) > 1) {
      test_bf <- bfastmonitor(test_ts, start = c(2018, 1))
      vec[count] <- test_bf$breakpoint
    } else {
        # vec[count] <- 99
    }
    count <- count + 1
  }
}
vec
```



# Results

# Discussion

# Conclusion
