---
title: "Deforestation Detection"
author: "Brian Pondi, Jonathan Bahlmann"
date: "2/12/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

* Observe structure: Intro, Methods, Results, Discussion, Conclusion

# Introduction

# Methods

## Input Data and Preparations

* Package description
* PRODES data sorted by years can be found here: [PRODES yearly deforestation](http://terrabrasilis.dpi.inpe.br/download/dataset/legal-amz-prodes/vector/yearly_deforestation.zip)

As seen in "final.Rmd". The subdirectory `L8cube_subregion` contains a NDVI time series as single `.tif` files, a file per acquisition, as input data.
```{r, warning=FALSE, message=FALSE}
library(stars)
library(gapfill)
library(bfast)
library(zoo)
library(raster)
subdir = "landsat_monthly"
f = paste0(subdir, "/", list.files(subdir))
st = merge(read_stars(f)) # make stars object
st = st[,1:60,1:60,]
plot(st)

# load PRODES data
# prod <- read_sf("./yearly_deforestation/yearly_deforestation.shp")
# prod_3857 <- st_make_valid(st_transform(prod, crs = st_crs(st)))
# prod_crop <- st_crop(prod_3857, st) # clip
# write_sf(prod_crop, "./yearly_deforestation/PRODES_cropped.shp", overwrite = TRUE)
prod <- read_sf("./yearly_deforestation/PRODES_cropped.shp")
# prod <- prod[prod$YEAR < 2019,]
```

```{r, warning=FALSE}
# whats in it?
# plot(st)
plot(as(st[,,,5], "Raster"))
plot(prod["YEAR"], add = TRUE)
plot(prod["YEAR"])
```

## Prepare for Gapfill

TODO: Introduce Gapfill, why did we chose this?

`Gapfill` documentation tells us that as input, a 4-dimensional numeric array is needed, with dimensions x, y, seasonal index (doy), year.
```{r}
# get pixels of whole dataset
imgdata <- c(st[,,,][[1]])

# make labels
xlab <- seq(from = attr(st, "dimensions")[[1]]$offset, by = attr(st, "dimensions")[[1]]$delta, length.out = attr(st, "dimensions")[[1]]$to)
ylab <- seq(from = attr(st, "dimensions")[[2]]$offset, by = attr(st, "dimensions")[[2]]$delta, length.out = attr(st, "dimensions")[[2]]$to)
doi <- c(1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335)
years <- seq(2013,2019,1)

# make array, transpose
h <- array(imgdata, dim = c(60, 60, 12, 7), dimnames = list(xlab, ylab, doi, years))
h <- aperm(h, c(2,1,3,4))

# all
Image(h[,,5,1:2])
# original stars
plot(st[,,,c(5, 17)])
```

## Gapfill

```{r}
# d <- Gapfill(h)
# saveRDS(d, "./all_smaller_100x100_Gapfill.rds")
g <- readRDS("all_smaller_100x100_Gapfill.rds")
# 60x60, iMax = infinite
Image(g$fill)

te <- Gapfill(h, iMax = 1)
Image(te$fill)

te2 <- Gapfill(h, iMax = 2)
Image(te2$fill)

te5 <- Gapfill(h, iMax = 5)
Image(te5$fill)

te20 <- Gapfill(h, iMax = 20)
Image(te20$fill)
```

```{r}
# ts of a pixel
x <- as.vector(g$fill[1,1,,])
# time must be given scaled to 1. -> monthly -> 1/12 = .08333333
# zoo must also be used in between, exactly as in ?bfastmonitor example
y <- as.ts(zoo(x, seq(2013, by = .08333333, length.out = 72))) 
y

bf <- bfastmonitor(y, start = c(2018, 1))
bf
plot(bf)
```


```{r}
# single pixel
defo_test <- st[st_geometry(prod[4,])]
defo_test_ts <- as.vector(defo_test[,3,3,][[1]])
test_ts <- as.ts(zoo(defo_test_ts, seq(2013, by = .08333333, length.out = 84))) 
test <- bfastmonitor(test_ts, start = c(2018, 1))
plot(test)

# mean of this polygon
mean_test <- st_apply(st[st_geometry(prod[2,])], "attributes", mean,  na.rm = TRUE) # aggregate
defo_test_ts <- mean_test[][[1]]
test_ts <- as.ts(zoo(defo_test_ts, seq(2013, by = .08333333, length.out = 84))) 
test <- bfastmonitor(test_ts, start = c(2018, 1))
plot(test)

# calculate breaks for every single pixel
vec <- c(0)
count <- 1
for (i in 1:5) {
  for (j in 1:12) {
    ts <- defo_test[,i,j,][[1]]
    test_ts <- as.ts(zoo(ts, seq(2013, by = .08333333, length.out = 84)))
    
    if (length(unique(test_ts)) > 1) {
      test_bf <- bfastmonitor(test_ts, start = c(2018, 1))
      vec[count] <- test_bf$breakpoint
    } else {
        # vec[count] <- 99
    }
    count <- count + 1
  }
}
vec
```

```{r}
Gapfill_matrix <- te20$fill
dims <- dim(Gapfill_matrix)

result <- matrix(rep(FALSE, dims[1]*dims[2]), ncol = dims[1])
for (i in 1:dims[1]) { # looping through x
  for (j in 1:dims[2]) { # loops through y
    raw_px_ts <- as.vector(Gapfill_matrix[i,j,,])
    px_ts_obj <- as.ts(zoo(raw_px_ts, seq(2013, by = .08333333, length.out = 84)))
    bfm_obj <- bfastmonitor(px_ts_obj, start = c(2019, 1))
    brkpoint <- bfm_obj$breakpoint
    if(!is.na(brkpoint)) {
      result[i,j] <- TRUE
    } else {
      # FALSE
    }
  }
}
```

```{r}
Image(result)
plot(prod["YEAR"])
```

```{r}
# example on building table
r <- raster(nrows=180, ncols=360, xmn=571823.6, xmx=616763.6, ymn=4423540, 
             ymx=4453690, resolution=300, crs = CRS("+proj=utm +zone=12 +datum=NAD83 
             +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0"))
 r[] <- round(runif(ncell(r),1,5),0)
 r2 <- aggregate(r, fact=2, fun=max)
 
ext <- as(extent(r), "SpatialPolygons")
pts <- sp::spsample(ext, type = "hexagonal", cellsize = 900)
pts <- SpatialPointsDataFrame(pts, data.frame(ID=1:length(pts)))

pts@data <- data.frame(pts@data, r=extract(r, pts))
pts@data <- data.frame(pts@data, r2=extract(r2, pts))

table(pts$r, pts$r2)
as.data.frame(table(pts$r, pts$r2))
```


# Results

# Discussion

# Conclusion
